C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CD4052
OBJECT MODULE PLACED IN .\output\cd4052.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE cd4052\cd4052.c LARGE BROWSE INCDIR(.\main;.\eeprom;.\oled;.\uart;.\74hc595
                    -;.\cd4052;.\isr;.\Key) DEBUG OBJECTEXTEND PRINT(.\list\cd4052.lst) OBJECT(.\output\cd4052.obj)

line level    source

   1          #include "main.h"
   2          #include "cd4052.h"
   3          #include "uart.h"
   4          #include "_595.h"
   5          #include "oled.h"
   6          #include "24c02.h"
   7          #include "key.h"
   8          #include "isr.h"
   9          
  10          CobPad PN;        //20线地址码
  11          CobPad PN_TMP;//临时存放不同封装地址码
  12          CobPad PN_CUT;//存放烧码后的地址，此地址码是实际烧出来的，不是预设码；需要和预设码对比
  13          Pad_Res RES;
  14          extern WINDOWS windemo;
  15          void PN_Mirro(void)
  16          {
  17   1        u32 tmp0,tmp2;
  18   1        u8 i;
  19   1        tmp0 = 0;
  20   1        tmp2 = 0;
  21   1        i = 0;
  22   1        for(i=0;i<24;i++)
  23   1        {
  24   2          tmp0 = (PN.PadByte>>i)&0x01;           //低位
  25   2              tmp2 |= (tmp0 << (23-i)) ;
  26   2        }
  27   1        PN.PadByte = tmp2;
  28   1      }
  29          void InitSign(void)
  30          {
  31   1        BUS_6 = 0;//输出第四位 
  32   1        BUS_5 = 0;//输出第三位
  33   1        BUS_4 = 0;//输出第二位
  34   1        BUS_3 = 0;//输出第一位
  35   1        BUS_2 = 0;//成功失败标志！
  36   1        BUS_1 = 1;//结束测试
  37   1      }
  38          void SignOut(u8 status,u32 xornum)
  39          {
  40   1      //  u8 tmp,i;
  41   1      //  tmp = 0;
  42   1      //  for(i=0;i<24;i++)   //转信号码
  43   1      //  {
  44   1      //    if((xornum>>i)&0x01)
  45   1      //      {
  46   1      //        tmp+=i;
  47   1      //      }
  48   1      //  }
  49   1        BUS_2 = status; //成功失败标志！
  50   1        BUS_1 = 0; //成功失败标志
  51   1      //  BUS_3 = tmp&0x01;//输出第一位
  52   1      //  BUS_4 = (tmp>>1)&0x01;//输出第二位
  53   1      //  BUS_5 = (tmp>>2)&0x01;//输出第三位
  54   1      //  BUS_6 = (tmp>>3)&0x01;//输出第四位
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 2   

  55   1      }
*** WARNING C280 IN LINE 38 OF CD4052\CD4052.C: 'xornum': unreferenced local variable
  56          /********************************************
  57          函数功能： ADC初始化
  58          返回 ： void
  59          备注  ：无
  60          *********************************************/
  61          void InitADC(void)
  62          {
  63   1          P1ASF = 0xff;                   //设置P1口为AD口
  64   1          ADC_RES = 0;                    //清除结果寄存器
  65   1              ADC_RESL = 0; 
  66   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL;
  67   1      }
  68          
  69          /********************************************
  70          函数功能： 获取ADC转换值
  71          返回 ： ADC值，10位ADC
  72          备注  ：无
  73          *********************************************/
  74          u16 GetADCResult(u8 Chanel)
  75          {
  76   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL | Chanel | ADC_START;
  77   1          _nop_();                        //等待4个NOP
  78   1          _nop_();
  79   1          _nop_();
  80   1          _nop_();
  81   1          while (!(ADC_CONTR & ADC_FLAG));//等待ADC转换完成
  82   1          ADC_CONTR &= ~ADC_FLAG;         //Close ADC
  83   1          return ((ADC_RES<<2)+ADC_RESL);  //返回ADC结果  10bit
  84   1      }
  85          /******************************************************************************************
  86          AD值转换为电阻值
  87          R2=AD*R1/(1024-AD)        R1 = 1M = 1000K
  88          返回的是PAD脚对地阻值大小，单位为K欧
  89          ******************************************************************************************/
  90          u16 Adc2Res(u16 adValue)
  91          {
  92   1        return (((u32)adValue*1000/(1024-adValue)));
  93   1      }
  94          /*******************************************************************************************
  95          ADC通道列表，对应不同PAD脚
  96          //A1            0                 0                1             1
  97          //B1            0                 1                0             1
  98          //A2            0                 0                1             1
  99          //B2            0                 1                0             1
 100          //--------------------------------------------------------------------------------------------
 101          //AD0      PAD0          PAD1     PAD2          PAD3
 102          //AD1      PAD4          PAD5     PAD6          PAD7
 103          //AD2      PAD8          PAD9     PAD10         PAD11
 104          //AD3      PAD12         PAD13    PAD14         PAD15
 105          //-------------------------------------------------------------------------------------------
 106          //AD4      PAD16
 107          //AD5      PAD17
 108          //AD6      PAD18
 109          //AD7      PAD19
 110          *******************************************************************************************/
 111          void GetPadRes(void)
 112          {
 113   1        u8 i;
 114   1        A1_4052 = 0;
 115   1        A2_4052 = 0;
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 3   

 116   1        B1_4052 = 0;
 117   1        B2_4052 = 0;
 118   1        delay_10ms();
 119   1        delay_10ms();
 120   1        delay_10ms();   //一定要延时等待4052开关切换ok
 121   1        RES.Pad0 = Adc2Res(GetADCResult(CH0));
 122   1        NOP4();
 123   1        RES.Pad4 = Adc2Res(GetADCResult(CH1));
 124   1      //  printf_u8(RES.Pad4>>8);
 125   1      //  printf_u8(RES.Pad4);
 126   1        NOP4();
 127   1        RES.Pad8 = Adc2Res(GetADCResult(CH2));
 128   1        NOP4();
 129   1        RES.Pad12 = Adc2Res(GetADCResult(CH3));
 130   1        NOP4();
 131   1      
 132   1        RES.Pad16 = Adc2Res(GetADCResult(CH4));
 133   1      //  printf_u8(RES.Pad16>>8);
 134   1      //  printf_u8(RES.Pad16);
 135   1        NOP4();
 136   1        RES.Pad17 = Adc2Res(GetADCResult(CH5));
 137   1        NOP4();
 138   1        RES.Pad18 = Adc2Res(GetADCResult(CH6));
 139   1        NOP4();
 140   1        RES.Pad19 = Adc2Res(GetADCResult(CH7));
 141   1      
 142   1      //i=200;
 143   1      //while(i--)
 144   1      {
 145   2        A1_4052 = 0;
 146   2        A2_4052 = 0;
 147   2        B1_4052 = 1;
 148   2        B2_4052 = 1;
 149   2        delay_10ms();
 150   2        delay_10ms();
 151   2        delay_10ms();   //一定要延时等待4052开关切换ok
 152   2        RES.Pad1 = Adc2Res(GetADCResult(CH0));
 153   2      //  printf_u8(RES.Pad1>>8);
 154   2      //  printf_u8(RES.Pad1);
 155   2        NOP4();
 156   2        RES.Pad5 = Adc2Res(GetADCResult(CH1));
 157   2        NOP4();
 158   2      //  printf_u8(RES.Pad5>>8);
 159   2      //  printf_u8(RES.Pad5);
 160   2        RES.Pad9 = Adc2Res(GetADCResult(CH2));
 161   2        NOP4();
 162   2        RES.Pad13 = Adc2Res(GetADCResult(CH3));
 163   2      }
 164   1        A1_4052 = 1;
 165   1        A2_4052 = 1;
 166   1        B1_4052 = 0;
 167   1        B2_4052 = 0;
 168   1        delay_10ms();
 169   1        delay_10ms();
 170   1        delay_10ms();   //一定要延时等待4052开关切换ok
 171   1        RES.Pad2 = Adc2Res(GetADCResult(CH0));
 172   1        NOP4();
 173   1        RES.Pad6 = Adc2Res(GetADCResult(CH1));
 174   1        NOP4();
 175   1        RES.Pad10 = Adc2Res(GetADCResult(CH2));
 176   1        NOP4();
 177   1        RES.Pad14 = Adc2Res(GetADCResult(CH3));
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 4   

 178   1      
 179   1        A1_4052 = 1;
 180   1        A2_4052 = 1;
 181   1        B1_4052 = 1;
 182   1        B2_4052 = 1;
 183   1        delay_10ms();
 184   1        delay_10ms();
 185   1        delay_10ms();   //一定要延时等待4052开关切换ok
 186   1        RES.Pad3 = Adc2Res(GetADCResult(CH0));
 187   1        NOP4();
 188   1        RES.Pad7 = Adc2Res(GetADCResult(CH1));
 189   1        NOP4();
 190   1        RES.Pad11 = Adc2Res(GetADCResult(CH2));
 191   1      //  printf_u8(RES.Pad11>>8);
 192   1      //  printf_u8(RES.Pad11);
 193   1        NOP4();
 194   1        RES.Pad15 = Adc2Res(GetADCResult(CH3));
 195   1      }
*** WARNING C280 IN LINE 113 OF CD4052\CD4052.C: 'i': unreferenced local variable
 196          /*****************************************************************************************
 197          功能：将不同封装临时地址码转换为真正的芯片地址码
 198          
 199          ******************************************************************************************/
 200          void PnMask(u8 package)
 201          {
 202   1        PN.PadByte = 0;   //复位地址码,没割码状态
 203   1        if(package == Package_2)                                       //封装1
 204   1        {
 205   2       //    PN.Px.P_XXH.Pad0 = PN_TMP.Px.P_XXH.Pad0;
 206   2           PN.Px.P_XXH.Pad1 = PN_TMP.Px.P_XXH.Pad0;
 207   2           PN.Px.P_XXH.Pad3 = PN_TMP.Px.P_XXH.Pad1;
 208   2           PN.Px.P_XXH.Pad5 = PN_TMP.Px.P_XXH.Pad2;
 209   2           
 210   2           PN.Px.P_XXH.Pad7= PN_TMP.Px.P_XXH.Pad3;
 211   2           PN.Px.P_XHX.Pad1= PN_TMP.Px.P_XXH.Pad4;
 212   2           PN.Px.P_XHX.Pad3= PN_TMP.Px.P_XXH.Pad5;
 213   2           PN.Px.P_XHX.Pad4 = PN_TMP.Px.P_XXH.Pad6; 
 214   2      /*
 215   2           PN.Px.P_XHX.Pad7 = PN_TMP.Px.P_XHX.Pad0;
 216   2           
 217   2           PN.Px.P_HXX.Pad1 = PN_TMP.Px.P_XHX.Pad1;
 218   2           PN.Px.P_HXX.Pad2 = PN_TMP.Px.P_XHX.Pad2;
 219   2           PN.Px.P_HXX.Pad3 = PN_TMP.Px.P_XHX.Pad3; 
 220   2      */                               
 221   2        }
 222   1        else if(package == Package_1)                     //封装2
 223   1        {
 224   2           PN.Px.P_XXH.Pad0 = PN_TMP.Px.P_XXH.Pad0;
 225   2           PN.Px.P_XXH.Pad2 = PN_TMP.Px.P_XXH.Pad1;
 226   2           PN.Px.P_XXH.Pad4 = PN_TMP.Px.P_XXH.Pad2;
 227   2           PN.Px.P_XXH.Pad6 = PN_TMP.Px.P_XXH.Pad3;
 228   2           
 229   2           PN.Px.P_XHX.Pad0 = PN_TMP.Px.P_XXH.Pad4;
 230   2           PN.Px.P_XHX.Pad2 = PN_TMP.Px.P_XXH.Pad5;
 231   2           PN.Px.P_XHX.Pad3 = PN_TMP.Px.P_XXH.Pad6;
 232   2           PN.Px.P_XHX.Pad4 = PN_TMP.Px.P_XXH.Pad7;  
 233   2        }
 234   1        else
 235   1        {
 236   2         PN.PadByte = PN_TMP.PadByte;               //无错位直接转换
 237   2        }
 238   1      }
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 5   

 239          /************************************************************************************************
 240          只判断要求被烧码PAD
 241          烧码结果： 1：成功    ；   0：失败
 242          ************************************************************************************************/
 243          bool BurnCheck(void)
 244          {
 245   1        bool ret;
 246   1        ret = 1;
 247   1        PN_CUT.PadByte = 0;                   //复位检测码
 248   1      
 249   1        if(PN_TMP.Px.P_XXH.Pad0== 1)
 250   1        {
 251   2          if(RES.Pad0 >= Res_OK)                    //烧码成功
 252   2          {
 253   3           PN_CUT.Px.P_XXH.Pad0= 1;
 254   3              }
 255   2              else                                     //烧码失败
 256   2              {
 257   3           ret = 0;                                      //需要直接返回吗
 258   3              }
 259   2        }
 260   1      
 261   1        if(PN_TMP.Px.P_XXH.Pad1 == 1)
 262   1        {
 263   2          if(RES.Pad1 >= Res_OK)                    //烧码成功
 264   2          {
 265   3           PN_CUT.Px.P_XXH.Pad1= 1;
 266   3              }
 267   2              else                                     //烧码失败
 268   2              {
 269   3           ret = 0;                                       //需要直接返回吗
 270   3              }
 271   2        }
 272   1      
 273   1        if(PN_TMP.Px.P_XXH.Pad2== 1)
 274   1        {
 275   2          if(RES.Pad2 >= Res_OK)                    //烧码成功
 276   2          {
 277   3           PN_CUT.Px.P_XXH.Pad2 = 1;
 278   3              }
 279   2              else                                     //烧码失败
 280   2              {
 281   3           ret = 0;                                       //需要直接返回吗
 282   3              }
 283   2        }
 284   1      
 285   1        if(PN_TMP.Px.P_XXH.Pad3 == 1)
 286   1        {
 287   2          if(RES.Pad3 >= Res_OK)                    //烧码成功
 288   2          {
 289   3           PN_CUT.Px.P_XXH.Pad3 = 1;
 290   3              }
 291   2              else                                     //烧码失败
 292   2              {
 293   3           ret = 0;                                       //需要直接返回吗
 294   3              }
 295   2        }
 296   1      
 297   1        if(PN_TMP.Px.P_XXH.Pad4 == 1)
 298   1        {
 299   2          if(RES.Pad4 >= Res_OK)                    //烧码成功
 300   2          {
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 6   

 301   3           PN_CUT.Px.P_XXH.Pad4 = 1;
 302   3              }
 303   2              else                                     //烧码失败
 304   2              {
 305   3           ret = 0;                                       //需要直接返回吗
 306   3              }
 307   2        }
 308   1      
 309   1        if(PN_TMP.Px.P_XXH.Pad5 == 1)
 310   1        {
 311   2          if(RES.Pad5 >= Res_OK)                    //烧码成功
 312   2          {
 313   3           PN_CUT.Px.P_XXH.Pad5 = 1;
 314   3              }
 315   2              else                                     //烧码失败
 316   2              {
 317   3           ret = 0;                                       //需要直接返回吗
 318   3              }
 319   2        }
 320   1      
 321   1        if(PN_TMP.Px.P_XXH.Pad6 == 1)
 322   1        {
 323   2          if(RES.Pad6 >= Res_OK)                    //烧码成功
 324   2          {
 325   3           PN_CUT.Px.P_XXH.Pad6 = 1;
 326   3              }
 327   2              else                                     //烧码失败
 328   2              {
 329   3           ret = 0;                                       //需要直接返回吗
 330   3              }
 331   2        }
 332   1      
 333   1        if(PN_TMP.Px.P_XXH.Pad7 == 1)
 334   1        {
 335   2          if(RES.Pad7 >= Res_OK)                    //烧码成功
 336   2          {
 337   3           PN_CUT.Px.P_XXH.Pad7 = 1;
 338   3              }
 339   2              else                                     //烧码失败
 340   2              {
 341   3           ret = 0;                                       //需要直接返回吗
 342   3              }
 343   2        }
 344   1      
 345   1        if(PN_TMP.Px.P_XHX.Pad0== 1)
 346   1        {
 347   2          if(RES.Pad8 >= Res_OK)                    //烧码成功
 348   2          {
 349   3           PN_CUT.Px.P_XHX.Pad0 = 1;
 350   3              }
 351   2              else                                     //烧码失败
 352   2              {
 353   3           ret = 0;                                       //需要直接返回吗
 354   3              }
 355   2        }
 356   1      
 357   1        if(PN_TMP.Px.P_XHX.Pad1 == 1)
 358   1        {
 359   2          if(RES.Pad9 >= Res_OK)                    //烧码成功
 360   2          {
 361   3           PN_CUT.Px.P_XHX.Pad1 = 1;
 362   3              }
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 7   

 363   2              else                                     //烧码失败
 364   2              {
 365   3           ret = 0;                                       //需要直接返回吗
 366   3              }
 367   2        }
 368   1      
 369   1        if(PN_TMP.Px.P_XHX.Pad2 == 1)
 370   1        {
 371   2          if(RES.Pad10 >= Res_OK)                    //烧码成功
 372   2          {
 373   3           PN_CUT.Px.P_XHX.Pad2 = 1;
 374   3              }
 375   2              else                                     //烧码失败
 376   2              {
 377   3           ret = 0;                                       //需要直接返回吗
 378   3              }
 379   2        }
 380   1      
 381   1        if(PN_TMP.Px.P_XHX.Pad3 == 1)
 382   1        {
 383   2          if(RES.Pad11 >= Res_OK)                    //烧码成功
 384   2          {
 385   3           PN_CUT.Px.P_XHX.Pad3 = 1;
 386   3              }
 387   2              else                                     //烧码失败
 388   2              {
 389   3           ret = 0;                                       //需要直接返回吗
 390   3              }
 391   2        }
 392   1      
 393   1        if(PN_TMP.Px.P_XHX.Pad4 == 1)
 394   1        {
 395   2          if(RES.Pad12 >= Res_OK)                    //烧码成功
 396   2          {
 397   3           PN_CUT.Px.P_XHX.Pad4 = 1;
 398   3              }
 399   2              else                                     //烧码失败
 400   2              {
 401   3           ret = 0;                                       //需要直接返回吗
 402   3              }
 403   2        }
 404   1      
 405   1        if(PN_TMP.Px.P_XHX.Pad5 == 1)
 406   1        {
 407   2          if(RES.Pad13 >= Res_OK)                    //烧码成功
 408   2          {
 409   3           PN_CUT.Px.P_XHX.Pad5 = 1;
 410   3              }
 411   2              else                                     //烧码失败
 412   2              {
 413   3           ret = 0;                                       //需要直接返回吗
 414   3              }
 415   2        }
 416   1      
 417   1        if(PN_TMP.Px.P_XHX.Pad6 == 1)
 418   1        {
 419   2          if(RES.Pad14 >= Res_OK)                    //烧码成功
 420   2          {
 421   3           PN_CUT.Px.P_XHX.Pad6 = 1;
 422   3              }
 423   2              else                                     //烧码失败
 424   2              {
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 8   

 425   3           ret = 0;                                       //需要直接返回吗
 426   3              }
 427   2        }
 428   1      
 429   1        if(PN_TMP.Px.P_XHX.Pad7 == 1)
 430   1        {
 431   2          if(RES.Pad15 >= Res_OK)                    //烧码成功
 432   2          {
 433   3           PN_CUT.Px.P_XHX.Pad7 = 1;
 434   3              }
 435   2              else                                     //烧码失败
 436   2              {
 437   3           ret = 0;                                       //需要直接返回吗
 438   3              }
 439   2        }
 440   1      
 441   1        if(PN_TMP.Px.P_HXX.Pad0== 1)
 442   1        {
 443   2          if(RES.Pad16 >= Res_OK)                    //烧码成功
 444   2          {
 445   3           PN_CUT.Px.P_HXX.Pad0 = 1;
 446   3              }
 447   2              else                                     //烧码失败
 448   2              {
 449   3           ret = 0;                                       //需要直接返回吗
 450   3              }
 451   2        }
 452   1      
 453   1        if(PN_TMP.Px.P_HXX.Pad1 == 1)
 454   1        {
 455   2          if(RES.Pad17 >= Res_OK)                    //烧码成功
 456   2          {
 457   3           PN_CUT.Px.P_HXX.Pad1 = 1;
 458   3              }
 459   2              else                                     //烧码失败
 460   2              {
 461   3           ret = 0;                                       //需要直接返回吗
 462   3              }
 463   2        }
 464   1      
 465   1        if(PN_TMP.Px.P_HXX.Pad2 == 1)
 466   1        {
 467   2          if(RES.Pad18 >= Res_OK)                    //烧码成功
 468   2          {
 469   3           PN_CUT.Px.P_HXX.Pad2 = 1;
 470   3              }
 471   2              else                                     //烧码失败
 472   2              {
 473   3           ret = 0;                                       //需要直接返回吗
 474   3              }
 475   2        }
 476   1      
 477   1        if(PN_TMP.Px.P_HXX.Pad3 == 1)
 478   1        {
 479   2          if(RES.Pad19 >= Res_OK)                    //烧码成功
 480   2          {
 481   3           PN_CUT.Px.P_HXX.Pad3 = 1;
 482   3              }
 483   2              else                                     //烧码失败
 484   2              {
 485   3           ret = 0;                                       //需要直接返回吗
 486   3              }
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 9   

 487   2        }
 488   1        OLED_ShowAdd(0,0,PN_TMP.PadByte,PN_CUT.PadByte);
 489   1        OLED_Refresh_Gram();
 490   1        return   ret;
 491   1      }
 492          
 493          /*
 494          bool BurnCheck(void)
 495          {
 496            bool ret;
 497            ret = 1;
 498            PN_CUT.PadByte = 0;                   //复位检测码
 499          
 500            if(PN.Px.P_XXH.Pad0== 1)
 501            {
 502              if(RES.Pad0 >= Res_OK)                    //烧码成功
 503              {
 504               PN_CUT.Px.P_XXH.Pad0= 1;
 505                  }
 506                  else                                     //烧码失败
 507                  {
 508               ret = 0;                                      //需要直接返回吗
 509                  }
 510            }
 511          
 512            if(PN.Px.P_XXH.Pad1 == 1)
 513            {
 514              if(RES.Pad1 >= Res_OK)                    //烧码成功
 515              {
 516               PN_CUT.Px.P_XXH.Pad1= 1;
 517                  }
 518                  else                                     //烧码失败
 519                  {
 520               ret = 0;                                       //需要直接返回吗
 521                  }
 522            }
 523          
 524            if(PN.Px.P_XXH.Pad2== 1)
 525            {
 526              if(RES.Pad2 >= Res_OK)                    //烧码成功
 527              {
 528               PN_CUT.Px.P_XXH.Pad2 = 1;
 529                  }
 530                  else                                     //烧码失败
 531                  {
 532               ret = 0;                                       //需要直接返回吗
 533                  }
 534            }
 535          
 536            if(PN.Px.P_XXH.Pad3 == 1)
 537            {
 538              if(RES.Pad3 >= Res_OK)                    //烧码成功
 539              {
 540               PN_CUT.Px.P_XXH.Pad3 = 1;
 541                  }
 542                  else                                     //烧码失败
 543                  {
 544               ret = 0;                                       //需要直接返回吗
 545                  }
 546            }
 547          
 548            if(PN.Px.P_XXH.Pad4 == 1)
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 10  

 549            {
 550              if(RES.Pad4 >= Res_OK)                    //烧码成功
 551              {
 552               PN_CUT.Px.P_XXH.Pad4 = 1;
 553                  }
 554                  else                                     //烧码失败
 555                  {
 556               ret = 0;                                       //需要直接返回吗
 557                  }
 558            }
 559          
 560            if(PN.Px.P_XXH.Pad5 == 1)
 561            {
 562              if(RES.Pad5 >= Res_OK)                    //烧码成功
 563              {
 564               PN_CUT.Px.P_XXH.Pad5 = 1;
 565                  }
 566                  else                                     //烧码失败
 567                  {
 568               ret = 0;                                       //需要直接返回吗
 569                  }
 570            }
 571          
 572            if(PN.Px.P_XXH.Pad6 == 1)
 573            {
 574              if(RES.Pad6 >= Res_OK)                    //烧码成功
 575              {
 576               PN_CUT.Px.P_XXH.Pad6 = 1;
 577                  }
 578                  else                                     //烧码失败
 579                  {
 580               ret = 0;                                       //需要直接返回吗
 581                  }
 582            }
 583          
 584            if(PN.Px.P_XXH.Pad7 == 1)
 585            {
 586              if(RES.Pad7 >= Res_OK)                    //烧码成功
 587              {
 588               PN_CUT.Px.P_XXH.Pad7 = 1;
 589                  }
 590                  else                                     //烧码失败
 591                  {
 592               ret = 0;                                       //需要直接返回吗
 593                  }
 594            }
 595          
 596            if(PN.Px.P_XHX.Pad0== 1)
 597            {
 598              if(RES.Pad8 >= Res_OK)                    //烧码成功
 599              {
 600               PN_CUT.Px.P_XHX.Pad0 = 1;
 601                  }
 602                  else                                     //烧码失败
 603                  {
 604               ret = 0;                                       //需要直接返回吗
 605                  }
 606            }
 607          
 608            if(PN.Px.P_XHX.Pad1 == 1)
 609            {
 610              if(RES.Pad9 >= Res_OK)                    //烧码成功
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 11  

 611              {
 612               PN_CUT.Px.P_XHX.Pad1 = 1;
 613                  }
 614                  else                                     //烧码失败
 615                  {
 616               ret = 0;                                       //需要直接返回吗
 617                  }
 618            }
 619          
 620            if(PN.Px.P_XHX.Pad2 == 1)
 621            {
 622              if(RES.Pad10 >= Res_OK)                    //烧码成功
 623              {
 624               PN_CUT.Px.P_XHX.Pad2 = 1;
 625                  }
 626                  else                                     //烧码失败
 627                  {
 628               ret = 0;                                       //需要直接返回吗
 629                  }
 630            }
 631          
 632            if(PN.Px.P_XHX.Pad3 == 1)
 633            {
 634              if(RES.Pad11 >= Res_OK)                    //烧码成功
 635              {
 636               PN_CUT.Px.P_XHX.Pad3 = 1;
 637                  }
 638                  else                                     //烧码失败
 639                  {
 640               ret = 0;                                       //需要直接返回吗
 641                  }
 642            }
 643          
 644            if(PN.Px.P_XHX.Pad4 == 1)
 645            {
 646              if(RES.Pad12 >= Res_OK)                    //烧码成功
 647              {
 648               PN_CUT.Px.P_XHX.Pad4 = 1;
 649                  }
 650                  else                                     //烧码失败
 651                  {
 652               ret = 0;                                       //需要直接返回吗
 653                  }
 654            }
 655          
 656            if(PN.Px.P_XHX.Pad5 == 1)
 657            {
 658              if(RES.Pad13 >= Res_OK)                    //烧码成功
 659              {
 660               PN_CUT.Px.P_XHX.Pad5 = 1;
 661                  }
 662                  else                                     //烧码失败
 663                  {
 664               ret = 0;                                       //需要直接返回吗
 665                  }
 666            }
 667          
 668            if(PN.Px.P_XHX.Pad6 == 1)
 669            {
 670              if(RES.Pad14 >= Res_OK)                    //烧码成功
 671              {
 672               PN_CUT.Px.P_XHX.Pad6 = 1;
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 12  

 673                  }
 674                  else                                     //烧码失败
 675                  {
 676               ret = 0;                                       //需要直接返回吗
 677                  }
 678            }
 679          
 680            if(PN.Px.P_XHX.Pad7 == 1)
 681            {
 682              if(RES.Pad15 >= Res_OK)                    //烧码成功
 683              {
 684               PN_CUT.Px.P_XHX.Pad7 = 1;
 685                  }
 686                  else                                     //烧码失败
 687                  {
 688               ret = 0;                                       //需要直接返回吗
 689                  }
 690            }
 691          
 692            if(PN.Px.P_HXX.Pad0== 1)
 693            {
 694              if(RES.Pad16 >= Res_OK)                    //烧码成功
 695              {
 696               PN_CUT.Px.P_HXX.Pad0 = 1;
 697                  }
 698                  else                                     //烧码失败
 699                  {
 700               ret = 0;                                       //需要直接返回吗
 701                  }
 702            }
 703          
 704            if(PN.Px.P_HXX.Pad1 == 1)
 705            {
 706              if(RES.Pad17 >= Res_OK)                    //烧码成功
 707              {
 708               PN_CUT.Px.P_HXX.Pad1 = 1;
 709                  }
 710                  else                                     //烧码失败
 711                  {
 712               ret = 0;                                       //需要直接返回吗
 713                  }
 714            }
 715          
 716            if(PN.Px.P_HXX.Pad2 == 1)
 717            {
 718              if(RES.Pad18 >= Res_OK)                    //烧码成功
 719              {
 720               PN_CUT.Px.P_HXX.Pad2 = 1;
 721                  }
 722                  else                                     //烧码失败
 723                  {
 724               ret = 0;                                       //需要直接返回吗
 725                  }
 726            }
 727          
 728            if(PN.Px.P_HXX.Pad3 == 1)
 729            {
 730              if(RES.Pad19 >= Res_OK)                    //烧码成功
 731              {
 732               PN_CUT.Px.P_HXX.Pad3 = 1;
 733                  }
 734                  else                                     //烧码失败
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 13  

 735                  {
 736               ret = 0;                                       //需要直接返回吗
 737                  }
 738            }
 739            OLED_ShowAdd(0,0,PN.PadByte,PN_CUT.PadByte);
 740            OLED_Refresh_Gram();
 741            return   ret;
 742          }
 743           */
 744          u8 Hex2Dat(u8 dat)
 745          {
 746   1         u8 dat0;
 747   1         if(dat<0x0a)
 748   1         {
 749   2             dat0 = dat+'0';
 750   2         }
 751   1         else
 752   1         {
 753   2             dat0 = dat+'A'-10;
 754   2         }
 755   1         return dat0;
 756   1      }  
 757          /************************************************************************************************
 758          比对烧码地址
 759          ************************************************************************************************/
 760          void Decode(u8 status)
 761          {
 762   1          u32 IRtmp[3];
 763   1              u32 Xornum;
 764   1              u8 i,j;
 765   1              ReIRcode = 0;
 766   1          EnDecode();
 767   1          delay_10ms(); 
 768   1          delay_10ms(); 
 769   1              K1_OUT = 1;
 770   1          delay_10ms(); 
 771   1          delay_10ms(); 
 772   1          delay_10ms(); 
 773   1          delay_10ms(); 
 774   1          delay_10ms(); 
 775   1          delay_10ms(); 
 776   1          delay_10ms(); 
 777   1       
 778   1          delay_10ms(); 
 779   1          delay_10ms(); 
 780   1          delay_10ms(); 
 781   1          delay_10ms(); 
 782   1      
 783   1              memcpy(OLED_GRAM_TMP,OLED_GRAM,512);
 784   1              init_windows(0,0,120,32,"Code No.:",0,0);
 785   1              OLED_Draw_WindowsDraw(&windemo);
 786   1              i = 200;
 787   1              j = 0;  
 788   1          while(i--)
 789   1              {
 790   2                      if((ReIRcode & 0x0f) != 0)
 791   2                      {
 792   3                        IRtmp[j++] = ReIRcode;
 793   3                        if(j>2) 
 794   3                        { 
 795   4                          j = 0;
 796   4                          if(IRtmp[1]==IRtmp[2])
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 14  

 797   4                          break;
 798   4                        }
 799   3                      }
 800   2      
 801   2              }
 802   1          OLED_ShowChar(22,16,Hex2Dat(((IRtmp[1] >>16)>>4)&0x0f),12,1);
 803   1          OLED_ShowChar(30,16,Hex2Dat(((IRtmp[1]>>16)&0x0f)),12,1);
 804   1      
 805   1              OLED_ShowChar(42,16,Hex2Dat(((IRtmp[1] >>8)>>4)&0x0f),12,1);
 806   1              OLED_ShowChar(50,16,Hex2Dat(((IRtmp[1] >>8)&0x0f)),12,1);
 807   1      
 808   1              OLED_ShowChar(62,16,Hex2Dat(((IRtmp[1])>>4)&0x0f),12,1);
 809   1              OLED_ShowChar(70,16,Hex2Dat(((IRtmp[1])&0x0f)),12,1);
 810   1      
 811   1              POP = 1;
 812   1              OLED_Refresh_Gram();
 813   1              PN_Mirro();
 814   1              Xornum = (PN.PadByte |0x4)^IRtmp[1];
 815   1              SignOut(status,Xornum);
 816   1      
 817   1      //  printf_u8((PN.PadByte )>>16);
 818   1      //  printf_u8((PN.PadByte)>>8);
 819   1      //  printf_u8(PN.PadByte );
 820   1      //  put_char('\n');
 821   1      //  printf_u8(((PN.PadByte )|0x4)>>16);
 822   1      //  printf_u8(((PN.PadByte )|0x4)>>8);
 823   1      //  printf_u8(((PN.PadByte )|0x4));
 824   1      //  put_char('\n');
 825   1      //  printf_u8(IRtmp>>16);
 826   1      //  printf_u8(IRtmp>>8);
 827   1      //  printf_u8(IRtmp);
 828   1      //  put_char('\n');
 829   1      //  printf_u8(Xornum>>16);
 830   1      //  printf_u8(Xornum>>8);
 831   1      //  printf_u8(Xornum);
 832   1      //  put_char('\n');
 833   1      }
 834          
 835          void compareAdd(void)
 836          {
 837   1        u32 tmp;
 838   1        u32 countmp;
 839   1        u8 status;
 840   1        if(BurnCheck() == 0)  //判断烧码脚烧码失败
 841   1        {
 842   2          status = NG;
 843   2              tmp = PN.PadByte^PN_CUT.PadByte;  //tmp 存放异常地址码 可以判断出在哪一位出现异常
 844   2          OLED_ShowChar(0,8,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 845   2          OLED_ShowChar(6,8,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 846   2      
 847   2              OLED_ShowChar(12,8,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 848   2              OLED_ShowChar(18,8,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 849   2      
 850   2              OLED_ShowChar(24,8,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 851   2              OLED_ShowChar(30,8,Hex2Dat(((tmp)&0x0f)),7,1);
 852   2          OLED_ShowString(0,24," NG!! ",7,1);
 853   2          OLED_Refresh_Gram();
 854   2                 //这里添加烧码失败操作 显示 给信号测试机   地址码不变
 855   2      /**********************************************************************************************/
 856   2              NG_COUNT++;
 857   2      #ifdef EEPROM_EN
 858   2              if(PKG == Package_1)
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 15  

 859   2              {
 860   3                at24c02_rddat(COUNT1_NG_ADD,&countmp,4);
 861   3                countmp++;
 862   3            at24c02_wrdat(COUNT1_NG_ADD,&countmp,4);    //累加 NG数量
 863   3              }
 864   2              else if(PKG == Package_2)
 865   2              {
 866   3                at24c02_rddat(COUNT2_NG_ADD,&countmp,4);
 867   3                countmp++;
 868   3            at24c02_wrdat(COUNT2_NG_ADD,&countmp,4);    //累加 NG数量
 869   3              }
 870   2              else if(PKG == Package_3)
 871   2              {
 872   3                at24c02_rddat(COUNT3_NG_ADD,&countmp,4);
 873   3                countmp ++;
 874   3            at24c02_wrdat(COUNT3_NG_ADD,&countmp,4);    //累加 NG数量
 875   3              }
 876   2              at24c02_rddat(COUNTALL_NG_ADD,&countmp,4);
 877   2              countmp ++;
 878   2              at24c02_wrdat(COUNTALL_NG_ADD,&countmp,4);    //累加 NG数量  
 879   2      #endif
 880   2      /***********************************************************************************************/
 881   2        }
 882   1        else
 883   1        {
 884   2          status = PASS;
 885   2          OLED_ShowString(0,8,"      ",7,1);
 886   2          OLED_ShowString(0,24,"PASS!!",7,1);
 887   2          OLED_Refresh_Gram();
 888   2                 //解码判断码值和地址码匹配
 889   2                 //这里添加烧码成功操作 显示  给信号测试机   地址码自加1
 890   2              PN_TMP.PadByte ++;
 891   2              if((PKG == Package_1)||(PKG == Package_2))
 892   2              {
 893   3                if(PN_TMP.PadByte > 0xff)        //2^8 不能超出地址空间
 894   3                PN_TMP.PadByte = 0;
 895   3      #ifdef EEPROM_EN
 896   3                if(PKG == Package_1)
 897   3                {
 898   4                  at24c02_wrdat(PKG1_ADD,&PN_TMP.PadByte,4);                   //储存割码地址到2402
 899   4                }
 900   3                else
 901   3                {
 902   4                  at24c02_wrdat(PKG2_ADD,&PN_TMP.PadByte,4);                   //储存割码地址到2402
 903   4                }
 904   3      #endif
 905   3              }
 906   2              else if(PKG == Package_3)
 907   2              {
 908   3                 if(PN_TMP.PadByte >= MaxlineHex)       //2^20  不能超出地址空间
 909   3                 PN_TMP.PadByte = 0;
 910   3      #ifdef EEPROM_EN
 911   3                 at24c02_wrdat(PKG3_ADD,&PN_TMP.PadByte,4);                    //储存割码地址到2402
 912   3      #endif                  
 913   3              }
 914   2      
 915   2      /*****************************************************************************************/
 916   2              OK_COUNT++;
 917   2      #ifdef EEPROM_EN
 918   2              if(PKG == Package_1)
 919   2              {
 920   3                at24c02_rddat(COUNT1_OK_ADD,&countmp,4);
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 16  

 921   3                countmp ++;
 922   3            at24c02_wrdat(COUNT1_OK_ADD,&countmp,4);    //累加 OK数量
 923   3              }
 924   2              else if(PKG == Package_2)
 925   2              {
 926   3                at24c02_rddat(COUNT2_OK_ADD,&countmp,4);
 927   3                countmp ++;
 928   3            at24c02_wrdat(COUNT2_OK_ADD,&countmp,4);    //累加 OK数量
 929   3              }
 930   2              else if(PKG == Package_3)
 931   2              {
 932   3                at24c02_rddat(COUNT3_OK_ADD,&countmp,4);
 933   3                countmp ++;
 934   3            at24c02_wrdat(COUNT3_OK_ADD,&countmp,4);    //累加 OK数量
 935   3              }
 936   2              at24c02_rddat(COUNTALL_OK_ADD,&countmp,4);
 937   2              countmp ++;
 938   2              at24c02_wrdat(COUNTALL_OK_ADD,&countmp,4);    //累加 OK数量  
 939   2      #endif
 940   2      /*****************************************************************************************************/
 941   2        }
 942   1         Decode(status); 
 943   1      }
 944          /************************************************************************************************
 945          烧码
 946          ************************************************************************************************/
 947          void CobCuting(u32 Add)
 948          {
 949   1              storge595(&Add,4);
 950   1              ENVMOS();                     // 开mos电源
 951   1              ENABLE595();              // 开595控制mos开关
 952   1              Cutflag = 1;
 953   1      }
 954          
 955          void StartCut(u8 package)
 956          {
 957   1        DSENVSOC();
 958   1        PnMask(package);                //转码
 959   1        CobCuting(PN_TMP.PadByte);      //开始割码
 960   1        while(Cutflag)                          //等待割码完成 才可以去读引脚阻值
 961   1        NOP1();
 962   1        GetPadRes();                //读引脚阻值
 963   1        OLED_Clear();
 964   1        compareAdd();               //比较地址
 965   1      //  ENVSOC();
 966   1      }
 967          void ShowInfo(void)
 968          {
 969   1          u32 tmp;
 970   1      
 971   1              memcpy(OLED_GRAM_TMP,OLED_GRAM,512);
 972   1              init_windows(0,0,120,32,"Info",0,0);
 973   1              OLED_Draw_WindowsDraw(&windemo);
 974   1              tmp = Get_Pkg_CNT(PKG,0);
 975   1              if(PKG == Package_1)            OLED_ShowString(30,2,"VT62538-B1",7,1);   
 976   1              else if(PKG == Package_2)               OLED_ShowString(30,2,"VT62538-B2",7,1);
 977   1              else  OLED_ShowString(30,2,"COB",7,1);
 978   1              OLED_ShowString(2,11,"OK:",7,1);   //Disp ok!
 979   1          OLED_ShowChar(22,11,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 980   1          OLED_ShowChar(28,11,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 981   1      
 982   1              OLED_ShowChar(34,11,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 17  

 983   1              OLED_ShowChar(40,11,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 984   1      
 985   1              OLED_ShowChar(46,11,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 986   1              OLED_ShowChar(52,11,Hex2Dat(((tmp)&0x0f)),7,1);
 987   1      
 988   1              tmp = Get_Pkg_CNT(PKG,1);
 989   1              OLED_ShowString(62,11,"NG:",7,1);   //Disp ok!
 990   1          OLED_ShowChar(82,11,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 991   1          OLED_ShowChar(88,11,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 992   1      
 993   1              OLED_ShowChar(94,11,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 994   1              OLED_ShowChar(100,11,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 995   1      
 996   1              OLED_ShowChar(106,11,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 997   1              OLED_ShowChar(112,11,Hex2Dat(((tmp)&0x0f)),7,1);
 998   1      
 999   1              tmp = Get_Pkg_Add(PKG);
1000   1              OLED_ShowString(2,20,"ADD:",7,1);   //Disp ok!
1001   1          OLED_ShowChar(28,20,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
1002   1          OLED_ShowChar(34,20,Hex2Dat(((tmp>>16)&0x0f)),7,1);
1003   1      
1004   1              OLED_ShowChar(40,20,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
1005   1              OLED_ShowChar(46,20,Hex2Dat(((tmp>>8)&0x0f)),7,1);
1006   1      
1007   1              OLED_ShowChar(52,20,Hex2Dat(((tmp)>>4)&0x0f),7,1);
1008   1              OLED_ShowChar(58,20,Hex2Dat(((tmp)&0x0f)),7,1);
1009   1      
1010   1              POP = 2;
1011   1              OLED_Refresh_Gram();      
1012   1      }
1013          void CutRun(u8 package)
1014          {
1015   1        u8 Done;
1016   1        Done = 0;
1017   1        //获取封装信息
1018   1      #ifdef EEPROM_EN
1019   1          PN_TMP.PadByte = Get_Pkg_Add(package); //获取到对应封装割码地址
1020   1      #endif
1021   1              OLED_ShowString(30,0,"SADD-No.:",12,1); 
1022   1          OLED_ShowChar(0,15,Hex2Dat(((PN_TMP.PadByte>>16)>>4)&0x0f),12,1);
1023   1          OLED_ShowChar(8,15,Hex2Dat(((PN_TMP.PadByte>>16)&0x0f)),12,1);
1024   1      
1025   1              OLED_ShowChar(16,15,Hex2Dat(((PN_TMP.PadByte>>8)>>4)&0x0f),12,1);
1026   1              OLED_ShowChar(24,15,Hex2Dat(((PN_TMP.PadByte>>8)&0x0f)),12,1);
1027   1      
1028   1              OLED_ShowChar(32,15,Hex2Dat(((PN_TMP.PadByte)>>4)&0x0f),12,1);
1029   1              OLED_ShowChar(40,15,Hex2Dat(((PN_TMP.PadByte)&0x0f)),12,1);
1030   1          OLED_Refresh_Gram();
1031   1              memcpy(OLED_GRAM_TMP,OLED_GRAM,512);
1032   1        while(!Done)
1033   1        {
1034   2                if((Key_back == PR_START)&&(Key_change))
1035   2                {
1036   3                 Key_change=0; 
1037   3                 BeepFlag =1; 
1038   3                 InitSign();
1039   3      #ifdef PRINT_INFO
1040   3          send_string ("\n开始割码--->\n");
1041   3      #endif
1042   3             StartCut(package);
1043   3      #ifdef PRINT_INFO
1044   3          send_string ("\n完成割码\n");
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 18  

1045   3      #endif
1046   3                }
1047   2                if((Key_back == PR_OK)&&(Key_change))
1048   2                {
1049   3                 Key_change=0; 
1050   3                 BeepFlag =1;
1051   3                 ShowInfo();
1052   3                }      
1053   2                if((Key_back == PR_MOD)&&(Key_change))
1054   2                {
1055   3                 Key_change=0; 
1056   3                 BeepFlag =1;
1057   3                 Done = 1;
1058   3                }     
1059   2                if((Key_back == PR_SUB)&&(Key_change))
1060   2                {
1061   3                 Key_change=0; 
1062   3                 BeepFlag =1;
1063   3                 PN_TMP.PadByte ++;
1064   3                 OLED_Clear();
1065   3             OLED_ShowAdd(0,0,PN_TMP.PadByte,PN_TMP.PadByte);
1066   3             OLED_Refresh_Gram();
1067   3                }     
1068   2                if((Key_back == PR_ADD)&&(Key_change))
1069   2                {
1070   3                 Key_change=0; 
1071   3                 BeepFlag =1;
1072   3                 PN_TMP.PadByte --;
1073   3                 OLED_Clear();
1074   3             OLED_ShowAdd(0,0,PN_TMP.PadByte,PN_TMP.PadByte);
1075   3             OLED_Refresh_Gram();
1076   3                }                          
1077   2        }
1078   1      }
1079          /*
1080          void TestPn(void)
1081          {
1082            static u8 Done = 0;
1083            PN_TMP.PadByte = 0;
1084            PN.PadByte = 0;
1085            send_string("\nstart mask: package type 1 , PACK_ADD = 0 , IC_ADD = 0\n\n");
1086          //  PN_TMP.Px.Pad0 = 1;
1087          //  PN.Px.Pad1 = 1;
1088          //  printf_u8(PN_TMP.PadByte);
1089          //  printf_u8(PN.PadByte);
1090          //      send_string("   ===>masking...\n");
1091            while(!Done)
1092            {
1093                  PnMask(0);
1094          //      send_string("start mask: ");
1095          //      send_string("PACK_ADD=:");
1096          //      printf_u8(PN_TMP.PadByte>>24);
1097          //      printf_u8(PN_TMP.PadByte>>16);
1098          //      printf_u8(PN_TMP.PadByte>>8);
1099          //      printf_u8(PN_TMP.PadByte);
1100          //      send_string("   IC_ADD=:");
1101          //      printf_u8(PN.PadByte>>24);
1102          //      printf_u8(PN.PadByte>>16);
1103          //      printf_u8(PN.PadByte>>8);
1104          //      printf_u8(PN.PadByte);
1105          //      send_string("   ===>masking...\n");
1106          //      send_string("PACK_ADD.BIT0 = \n");
C51 COMPILER V9.00   CD4052                                                                04/27/2015 19:27:07 PAGE 19  

1107          //      printf_u8(PN_TMP.Px.Pad0);
1108                  send_string("\n");
1109                  send_string("PN_TMP BIT 15:0\n");
1110                  printf_u8(PN_TMP.Px.P_XHX.Pad7);
1111                  printf_u8(PN_TMP.Px.P_XHX.Pad6);
1112                  printf_u8(PN_TMP.Px.P_XHX.Pad5);
1113                  printf_u8(PN_TMP.Px.P_XHX.Pad4);
1114                  printf_u8(PN_TMP.Px.P_XHX.Pad3);
1115                  printf_u8(PN_TMP.Px.P_XHX.Pad2);
1116                  printf_u8(PN_TMP.Px.P_XHX.Pad1);
1117                  printf_u8(PN_TMP.Px.P_XHX.Pad0);        
1118                  
1119                  printf_u8(PN_TMP.Px.P_XXH.Pad7);
1120                  printf_u8(PN_TMP.Px.P_XXH.Pad6);
1121                  printf_u8(PN_TMP.Px.P_XXH.Pad5);
1122                  printf_u8(PN_TMP.Px.P_XXH.Pad4);
1123                  printf_u8(PN_TMP.Px.P_XXH.Pad3);
1124                  printf_u8(PN_TMP.Px.P_XXH.Pad2);
1125                  printf_u8(PN_TMP.Px.P_XXH.Pad1);
1126                  printf_u8(PN_TMP.Px.P_XXH.Pad0);
1127          //      send_string("\n");
1128                  send_string("PN_TMP BIT 15:0\n");
1129                  printf_u8(PN.Px.P_XHX.Pad7);
1130                  printf_u8(PN.Px.P_XHX.Pad6);
1131                  printf_u8(PN.Px.P_XHX.Pad5);
1132                  printf_u8(PN.Px.P_XHX.Pad4);
1133                  printf_u8(PN.Px.P_XHX.Pad3);
1134                  printf_u8(PN.Px.P_XHX.Pad2);
1135                  printf_u8(PN.Px.P_XHX.Pad1);
1136                  printf_u8(PN.Px.P_XHX.Pad0);    
1137                  
1138                  printf_u8(PN.Px.P_XXH.Pad7);
1139                  printf_u8(PN.Px.P_XXH.Pad6);
1140                  printf_u8(PN.Px.P_XXH.Pad5);
1141                  printf_u8(PN.Px.P_XXH.Pad4);
1142                  printf_u8(PN.Px.P_XXH.Pad3);
1143                  printf_u8(PN.Px.P_XXH.Pad2);
1144                  printf_u8(PN.Px.P_XXH.Pad1);
1145                  printf_u8(PN.Px.P_XXH.Pad0);
1146                  send_string("\n");              
1147                  if(PN_TMP.PadByte ++ >=0xfff)
1148                  Done = 1;
1149            }
1150                  send_string("mask over!\n");
1151          }
1152          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5258    ----
   CONSTANT SIZE    =    111    ----
   XDATA SIZE       =     52      53
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
