C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CD4052
OBJECT MODULE PLACED IN .\output\cd4052.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE cd4052\cd4052.c LARGE BROWSE INCDIR(.\main;.\eeprom;.\oled;.\uart;.\74hc595
                    -;.\cd4052;.\isr;.\Key) DEBUG OBJECTEXTEND PRINT(.\list\cd4052.lst) OBJECT(.\output\cd4052.obj)

line level    source

   1          #include "main.h"
   2          #include "cd4052.h"
   3          #include "uart.h"
   4          #include "_595.h"
   5          #include "oled.h"
   6          #include "24c02.h"
   7          #include "key.h"
   8          
   9          #define Res_OK  500//2000        //设置电阻判定值2000K=2M
  10          CobPad PN;        //20线地址码
  11          CobPad PN_TMP;//临时存放不同封装地址码
  12          CobPad PN_CUT;//存放烧码后的地址，此地址码是实际烧出来的，不是预设码；需要和预设码对比
  13          Pad_Res RES;
  14          extern WINDOWS windemo;
  15          /********************************************
  16          函数功能： ADC初始化
  17          返回 ： void
  18          备注  ：无
  19          *********************************************/
  20          void InitADC(void)
  21          {
  22   1          P1ASF = 0xff;                   //设置P1口为AD口
  23   1          ADC_RES = 0;                    //清除结果寄存器
  24   1              ADC_RESL = 0; 
  25   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL;
  26   1      }
  27          
  28          /********************************************
  29          函数功能： 获取ADC转换值
  30          返回 ： ADC值，10位ADC
  31          备注  ：无
  32          *********************************************/
  33          u16 GetADCResult(u8 Chanel)
  34          {
  35   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL | Chanel | ADC_START;
  36   1          _nop_();                        //等待4个NOP
  37   1          _nop_();
  38   1          _nop_();
  39   1          _nop_();
  40   1          while (!(ADC_CONTR & ADC_FLAG));//等待ADC转换完成
  41   1          ADC_CONTR &= ~ADC_FLAG;         //Close ADC
  42   1          return ((ADC_RES<<2)+ADC_RESL);  //返回ADC结果  10bit
  43   1      }
  44          /******************************************************************************************
  45          AD值转换为电阻值
  46          R2=AD*R1/(1024-AD)        R1 = 1M = 1000K
  47          返回的是PAD脚对地阻值大小，单位为K欧
  48          ******************************************************************************************/
  49          u16 Adc2Res(u16 adValue)
  50          {
  51   1        return (((u32)adValue*1000/(1024-adValue)));
  52   1      }
  53          /*******************************************************************************************
  54          ADC通道列表，对应不同PAD脚
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 2   

  55          //A1            0                 0                1             1
  56          //B1            0                 1                0             1
  57          //A2            0                 0                1             1
  58          //B2            0                 1                0             1
  59          //--------------------------------------------------------------------------------------------
  60          //AD0      PAD0          PAD1     PAD2          PAD3
  61          //AD1      PAD4          PAD5     PAD6          PAD7
  62          //AD2      PAD8          PAD9     PAD10         PAD11
  63          //AD3      PAD12         PAD13    PAD14         PAD15
  64          //-------------------------------------------------------------------------------------------
  65          //AD4      PAD16
  66          //AD5      PAD17
  67          //AD6      PAD18
  68          //AD7      PAD19
  69          *******************************************************************************************/
  70          void GetPadRes(void)
  71          {
  72   1        A1_4052 = 0;
  73   1        A2_4052 = 0;
  74   1        B1_4052 = 0;
  75   1        B2_4052 = 0;
  76   1        NOP10();
  77   1        RES.Pad0 = Adc2Res(GetADCResult(CH0));
  78   1        NOP4();
  79   1        RES.Pad4 = Adc2Res(GetADCResult(CH1));
  80   1        NOP4();
  81   1        RES.Pad8 = Adc2Res(GetADCResult(CH2));
  82   1        NOP4();
  83   1        RES.Pad12 = Adc2Res(GetADCResult(CH3));
  84   1      
  85   1        NOP4();
  86   1        RES.Pad16 = Adc2Res(GetADCResult(CH4));
  87   1      //  printf_u8(RES.Pad16>>8);
  88   1      //  printf_u8(RES.Pad16);
  89   1        NOP4();
  90   1        RES.Pad17 = Adc2Res(GetADCResult(CH5));
  91   1        NOP4();
  92   1        RES.Pad18 = Adc2Res(GetADCResult(CH6));
  93   1        NOP4();
  94   1        RES.Pad19 = Adc2Res(GetADCResult(CH7));
  95   1      
  96   1        A1_4052 = 0;
  97   1        A2_4052 = 0;
  98   1        B1_4052 = 1;
  99   1        B2_4052 = 1;
 100   1        NOP10();
 101   1        RES.Pad1 = Adc2Res(GetADCResult(CH0));
 102   1      //  printf_u8(RES.Pad1>>8);
 103   1      //  printf_u8(RES.Pad1);
 104   1        NOP4();
 105   1        RES.Pad5 = Adc2Res(GetADCResult(CH1));
 106   1        NOP4();
 107   1        RES.Pad9 = Adc2Res(GetADCResult(CH2));
 108   1        NOP4();
 109   1        RES.Pad13 = Adc2Res(GetADCResult(CH3));
 110   1      
 111   1        A1_4052 = 1;
 112   1        A2_4052 = 1;
 113   1        B1_4052 = 0;
 114   1        B2_4052 = 0;
 115   1        NOP10();
 116   1        RES.Pad2 = Adc2Res(GetADCResult(CH0));
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 3   

 117   1        NOP4();
 118   1        RES.Pad6 = Adc2Res(GetADCResult(CH1));
 119   1        NOP4();
 120   1        RES.Pad10 = Adc2Res(GetADCResult(CH2));
 121   1        NOP4();
 122   1        RES.Pad14 = Adc2Res(GetADCResult(CH3));
 123   1      
 124   1        A1_4052 = 1;
 125   1        A2_4052 = 1;
 126   1        B1_4052 = 1;
 127   1        B2_4052 = 1;
 128   1        NOP10();
 129   1        RES.Pad3 = Adc2Res(GetADCResult(CH0));
 130   1        NOP4();
 131   1        RES.Pad7 = Adc2Res(GetADCResult(CH1));
 132   1        NOP4();
 133   1        RES.Pad11 = Adc2Res(GetADCResult(CH2));
 134   1      //  printf_u8(RES.Pad11>>8);
 135   1      //  printf_u8(RES.Pad11);
 136   1        NOP4();
 137   1        RES.Pad15 = Adc2Res(GetADCResult(CH3));
 138   1      }
 139          /*****************************************************************************************
 140          功能：将不同封装临时地址码转换为真正的芯片地址码
 141          
 142          ******************************************************************************************/
 143          void PnMask(u8 package)
 144          {
 145   1        PN.PadByte = 0;   //复位地址码,没割码状态
 146   1        if(package == Package_2)                                       //封装1
 147   1        {
 148   2       //    PN.Px.P_XXH.Pad0 = PN_TMP.Px.P_XXH.Pad0;
 149   2           PN.Px.P_XXH.Pad1 = PN_TMP.Px.P_XXH.Pad0;
 150   2           PN.Px.P_XXH.Pad3 = PN_TMP.Px.P_XXH.Pad1;
 151   2           PN.Px.P_XXH.Pad5 = PN_TMP.Px.P_XXH.Pad2;
 152   2           
 153   2           PN.Px.P_XXH.Pad7= PN_TMP.Px.P_XXH.Pad3;
 154   2           PN.Px.P_XHX.Pad1= PN_TMP.Px.P_XXH.Pad4;
 155   2           PN.Px.P_XHX.Pad3= PN_TMP.Px.P_XXH.Pad5;
 156   2           PN.Px.P_XHX.Pad4 = PN_TMP.Px.P_XXH.Pad6; 
 157   2      /*
 158   2           PN.Px.P_XHX.Pad7 = PN_TMP.Px.P_XHX.Pad0;
 159   2           
 160   2           PN.Px.P_HXX.Pad1 = PN_TMP.Px.P_XHX.Pad1;
 161   2           PN.Px.P_HXX.Pad2 = PN_TMP.Px.P_XHX.Pad2;
 162   2           PN.Px.P_HXX.Pad3 = PN_TMP.Px.P_XHX.Pad3; 
 163   2      */                               
 164   2        }
 165   1        else if(package == Package_1)                     //封装2
 166   1        {
 167   2           PN.Px.P_XXH.Pad0 = PN_TMP.Px.P_XXH.Pad0;
 168   2           PN.Px.P_XXH.Pad2 = PN_TMP.Px.P_XXH.Pad1;
 169   2           PN.Px.P_XXH.Pad4 = PN_TMP.Px.P_XXH.Pad2;
 170   2           PN.Px.P_XXH.Pad6 = PN_TMP.Px.P_XXH.Pad3;
 171   2           
 172   2           PN.Px.P_XHX.Pad0 = PN_TMP.Px.P_XXH.Pad4;
 173   2           PN.Px.P_XHX.Pad2 = PN_TMP.Px.P_XXH.Pad5;
 174   2           PN.Px.P_XHX.Pad3 = PN_TMP.Px.P_XXH.Pad6;
 175   2           PN.Px.P_XHX.Pad4 = PN_TMP.Px.P_XXH.Pad7;  
 176   2        }
 177   1        else
 178   1        {
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 4   

 179   2         PN.PadByte = PN_TMP.PadByte;               //无错位直接转换
 180   2        }
 181   1      }
 182          /************************************************************************************************
 183          只判断要求被烧码PAD
 184          烧码结果： 1：成功    ；   0：失败
 185          ************************************************************************************************/
 186          bool BurnCheck(void)
 187          {
 188   1        bool ret;
 189   1        ret = 1;
 190   1        PN_CUT.PadByte = 0;                   //复位检测码
 191   1      
 192   1        if(PN.Px.P_XXH.Pad0== 1)
 193   1        {
 194   2          if(RES.Pad0 >= Res_OK)                    //烧码成功
 195   2          {
 196   3           PN_CUT.Px.P_XXH.Pad0= 1;
 197   3              }
 198   2              else                                     //烧码失败
 199   2              {
 200   3           ret = 0;                                      //需要直接返回吗
 201   3              }
 202   2        }
 203   1      
 204   1        if(PN.Px.P_XXH.Pad1 == 1)
 205   1        {
 206   2          if(RES.Pad1 >= Res_OK)                    //烧码成功
 207   2          {
 208   3           PN_CUT.Px.P_XXH.Pad1= 1;
 209   3              }
 210   2              else                                     //烧码失败
 211   2              {
 212   3           ret = 0;                                       //需要直接返回吗
 213   3              }
 214   2        }
 215   1      
 216   1        if(PN.Px.P_XXH.Pad2== 1)
 217   1        {
 218   2          if(RES.Pad2 >= Res_OK)                    //烧码成功
 219   2          {
 220   3           PN_CUT.Px.P_XXH.Pad2 = 1;
 221   3              }
 222   2              else                                     //烧码失败
 223   2              {
 224   3           ret = 0;                                       //需要直接返回吗
 225   3              }
 226   2        }
 227   1      
 228   1        if(PN.Px.P_XXH.Pad3 == 1)
 229   1        {
 230   2          if(RES.Pad3 >= Res_OK)                    //烧码成功
 231   2          {
 232   3           PN_CUT.Px.P_XXH.Pad3 = 1;
 233   3              }
 234   2              else                                     //烧码失败
 235   2              {
 236   3           ret = 0;                                       //需要直接返回吗
 237   3              }
 238   2        }
 239   1      
 240   1        if(PN.Px.P_XXH.Pad4 == 1)
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 5   

 241   1        {
 242   2          if(RES.Pad4 >= Res_OK)                    //烧码成功
 243   2          {
 244   3           PN_CUT.Px.P_XXH.Pad4 = 1;
 245   3              }
 246   2              else                                     //烧码失败
 247   2              {
 248   3           ret = 0;                                       //需要直接返回吗
 249   3              }
 250   2        }
 251   1      
 252   1        if(PN.Px.P_XXH.Pad5 == 1)
 253   1        {
 254   2          if(RES.Pad5 >= Res_OK)                    //烧码成功
 255   2          {
 256   3           PN_CUT.Px.P_XXH.Pad5 = 1;
 257   3              }
 258   2              else                                     //烧码失败
 259   2              {
 260   3           ret = 0;                                       //需要直接返回吗
 261   3              }
 262   2        }
 263   1      
 264   1        if(PN.Px.P_XXH.Pad6 == 1)
 265   1        {
 266   2          if(RES.Pad6 >= Res_OK)                    //烧码成功
 267   2          {
 268   3           PN_CUT.Px.P_XXH.Pad6 = 1;
 269   3              }
 270   2              else                                     //烧码失败
 271   2              {
 272   3           ret = 0;                                       //需要直接返回吗
 273   3              }
 274   2        }
 275   1      
 276   1        if(PN.Px.P_XXH.Pad7 == 1)
 277   1        {
 278   2          if(RES.Pad7 >= Res_OK)                    //烧码成功
 279   2          {
 280   3           PN_CUT.Px.P_XXH.Pad7 = 1;
 281   3              }
 282   2              else                                     //烧码失败
 283   2              {
 284   3           ret = 0;                                       //需要直接返回吗
 285   3              }
 286   2        }
 287   1      
 288   1        if(PN.Px.P_XHX.Pad0== 1)
 289   1        {
 290   2          if(RES.Pad8 >= Res_OK)                    //烧码成功
 291   2          {
 292   3           PN_CUT.Px.P_XHX.Pad0 = 1;
 293   3              }
 294   2              else                                     //烧码失败
 295   2              {
 296   3           ret = 0;                                       //需要直接返回吗
 297   3              }
 298   2        }
 299   1      
 300   1        if(PN.Px.P_XHX.Pad1 == 1)
 301   1        {
 302   2          if(RES.Pad9 >= Res_OK)                    //烧码成功
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 6   

 303   2          {
 304   3           PN_CUT.Px.P_XHX.Pad1 = 1;
 305   3              }
 306   2              else                                     //烧码失败
 307   2              {
 308   3           ret = 0;                                       //需要直接返回吗
 309   3              }
 310   2        }
 311   1      
 312   1        if(PN.Px.P_XHX.Pad2 == 1)
 313   1        {
 314   2          if(RES.Pad10 >= Res_OK)                    //烧码成功
 315   2          {
 316   3           PN_CUT.Px.P_XHX.Pad2 = 1;
 317   3              }
 318   2              else                                     //烧码失败
 319   2              {
 320   3           ret = 0;                                       //需要直接返回吗
 321   3              }
 322   2        }
 323   1      
 324   1        if(PN.Px.P_XHX.Pad3 == 1)
 325   1        {
 326   2          if(RES.Pad11 >= Res_OK)                    //烧码成功
 327   2          {
 328   3           PN_CUT.Px.P_XHX.Pad3 = 1;
 329   3              }
 330   2              else                                     //烧码失败
 331   2              {
 332   3           ret = 0;                                       //需要直接返回吗
 333   3              }
 334   2        }
 335   1      
 336   1        if(PN.Px.P_XHX.Pad4 == 1)
 337   1        {
 338   2          if(RES.Pad12 >= Res_OK)                    //烧码成功
 339   2          {
 340   3           PN_CUT.Px.P_XHX.Pad4 = 1;
 341   3              }
 342   2              else                                     //烧码失败
 343   2              {
 344   3           ret = 0;                                       //需要直接返回吗
 345   3              }
 346   2        }
 347   1      
 348   1        if(PN.Px.P_XHX.Pad5 == 1)
 349   1        {
 350   2          if(RES.Pad13 >= Res_OK)                    //烧码成功
 351   2          {
 352   3           PN_CUT.Px.P_XHX.Pad5 = 1;
 353   3              }
 354   2              else                                     //烧码失败
 355   2              {
 356   3           ret = 0;                                       //需要直接返回吗
 357   3              }
 358   2        }
 359   1      
 360   1        if(PN.Px.P_XHX.Pad6 == 1)
 361   1        {
 362   2          if(RES.Pad14 >= Res_OK)                    //烧码成功
 363   2          {
 364   3           PN_CUT.Px.P_XHX.Pad6 = 1;
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 7   

 365   3              }
 366   2              else                                     //烧码失败
 367   2              {
 368   3           ret = 0;                                       //需要直接返回吗
 369   3              }
 370   2        }
 371   1      
 372   1        if(PN.Px.P_XHX.Pad7 == 1)
 373   1        {
 374   2          if(RES.Pad15 >= Res_OK)                    //烧码成功
 375   2          {
 376   3           PN_CUT.Px.P_XHX.Pad7 = 1;
 377   3              }
 378   2              else                                     //烧码失败
 379   2              {
 380   3           ret = 0;                                       //需要直接返回吗
 381   3              }
 382   2        }
 383   1      
 384   1        if(PN.Px.P_HXX.Pad0== 1)
 385   1        {
 386   2          if(RES.Pad16 >= Res_OK)                    //烧码成功
 387   2          {
 388   3           PN_CUT.Px.P_HXX.Pad0 = 1;
 389   3              }
 390   2              else                                     //烧码失败
 391   2              {
 392   3           ret = 0;                                       //需要直接返回吗
 393   3              }
 394   2        }
 395   1      
 396   1        if(PN.Px.P_HXX.Pad1 == 1)
 397   1        {
 398   2          if(RES.Pad17 >= Res_OK)                    //烧码成功
 399   2          {
 400   3           PN_CUT.Px.P_HXX.Pad1 = 1;
 401   3              }
 402   2              else                                     //烧码失败
 403   2              {
 404   3           ret = 0;                                       //需要直接返回吗
 405   3              }
 406   2        }
 407   1      
 408   1        if(PN.Px.P_HXX.Pad2 == 1)
 409   1        {
 410   2          if(RES.Pad18 >= Res_OK)                    //烧码成功
 411   2          {
 412   3           PN_CUT.Px.P_HXX.Pad2 = 1;
 413   3              }
 414   2              else                                     //烧码失败
 415   2              {
 416   3           ret = 0;                                       //需要直接返回吗
 417   3              }
 418   2        }
 419   1      
 420   1        if(PN.Px.P_HXX.Pad3 == 1)
 421   1        {
 422   2          if(RES.Pad19 >= Res_OK)                    //烧码成功
 423   2          {
 424   3           PN_CUT.Px.P_HXX.Pad3 = 1;
 425   3              }
 426   2              else                                     //烧码失败
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 8   

 427   2              {
 428   3           ret = 0;                                       //需要直接返回吗
 429   3              }
 430   2        }
 431   1        OLED_ShowAdd(0,0,PN.PadByte,PN_CUT.PadByte);
 432   1        OLED_Refresh_Gram();
 433   1        return   ret;
 434   1      }
 435          
 436          u8 Hex2Dat(u8 dat)
 437          {
 438   1         u8 dat0;
 439   1         if(dat<0x0a)
 440   1         {
 441   2             dat0 = dat+'0';
 442   2         }
 443   1         else
 444   1         {
 445   2             dat0 = dat+'A'-10;
 446   2         }
 447   1         return dat0;
 448   1      }  
 449          /************************************************************************************************
 450          比对烧码地址
 451          ************************************************************************************************/
 452          void compareAdd(void)
 453          {
 454   1        u32 tmp;
 455   1        u32 countmp;
 456   1        if(BurnCheck() == 0)  //判断烧码脚烧码失败
 457   1        {
 458   2              tmp = PN.PadByte^PN_CUT.PadByte;  //tmp 存放异常地址码 可以判断出在哪一位出现异常
 459   2          OLED_ShowChar(0,8,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 460   2          OLED_ShowChar(6,8,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 461   2      
 462   2              OLED_ShowChar(12,8,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 463   2              OLED_ShowChar(18,8,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 464   2      
 465   2              OLED_ShowChar(24,8,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 466   2              OLED_ShowChar(30,8,Hex2Dat(((tmp)&0x0f)),7,1);
 467   2          OLED_ShowString(0,24," NG!! ",7,1);
 468   2          OLED_Refresh_Gram();
 469   2                 //这里添加烧码失败操作 显示 给信号测试机   地址码不变
 470   2      /**********************************************************************************************/
 471   2              NG_COUNT++;
 472   2      #ifdef EEPROM_EN
 473   2              if(PKG == Package_1)
 474   2              {
 475   3                at24c02_rddat(COUNT1_NG_ADD,&countmp,4);
 476   3                countmp++;
 477   3            at24c02_wrdat(COUNT1_NG_ADD,&countmp,4);    //累加 NG数量
 478   3              }
 479   2              else if(PKG == Package_2)
 480   2              {
 481   3                at24c02_rddat(COUNT2_NG_ADD,&countmp,4);
 482   3                countmp++;
 483   3            at24c02_wrdat(COUNT2_NG_ADD,&countmp,4);    //累加 NG数量
 484   3              }
 485   2              else if(PKG == Package_3)
 486   2              {
 487   3                at24c02_rddat(COUNT3_NG_ADD,&countmp,4);
 488   3                countmp ++;
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 9   

 489   3            at24c02_wrdat(COUNT3_NG_ADD,&countmp,4);    //累加 NG数量
 490   3              }
 491   2              at24c02_rddat(COUNTALL_NG_ADD,&countmp,4);
 492   2              countmp ++;
 493   2              at24c02_wrdat(COUNTALL_NG_ADD,&countmp,4);    //累加 NG数量  
 494   2      #endif
 495   2      /***********************************************************************************************/
 496   2        }
 497   1        else
 498   1        {
 499   2          OLED_ShowString(0,8,"      ",7,1);
 500   2          OLED_ShowString(0,24,"PASS!!",7,1);
 501   2          OLED_Refresh_Gram();
 502   2                 //解码判断码值和地址码匹配
 503   2                 //这里添加烧码成功操作 显示  给信号测试机   地址码自加1
 504   2              PN_TMP.PadByte ++;
 505   2              if((PKG == Package_1)||(PKG == Package_2))
 506   2              {
 507   3                if(PN_TMP.PadByte > 0xff)        //2^8 不能超出地址空间
 508   3                PN_TMP.PadByte = 0;
 509   3      #ifdef EEPROM_EN
 510   3                if(PKG == Package_1)
 511   3                {
 512   4                  at24c02_wrdat(PKG1_ADD,&PN_TMP.PadByte,4);                   //储存割码地址到2402
 513   4                }
 514   3                else
 515   3                {
 516   4                  at24c02_wrdat(PKG2_ADD,&PN_TMP.PadByte,4);                   //储存割码地址到2402
 517   4                }
 518   3      #endif
 519   3              }
 520   2              else if(PKG == Package_3)
 521   2              {
 522   3                 if(PN_TMP.PadByte > 0xfffff)   //2^20  不能超出地址空间
 523   3                 PN_TMP.PadByte = 0;
 524   3      #ifdef EEPROM_EN
 525   3                 at24c02_wrdat(PKG3_ADD,&PN_TMP.PadByte,4);                    //储存割码地址到2402
 526   3      #endif                  
 527   3              }
 528   2      
 529   2      /*****************************************************************************************/
 530   2              OK_COUNT++;
 531   2      #ifdef EEPROM_EN
 532   2              if(PKG == Package_1)
 533   2              {
 534   3                at24c02_rddat(COUNT1_OK_ADD,&countmp,4);
 535   3                countmp ++;
 536   3            at24c02_wrdat(COUNT1_OK_ADD,&countmp,4);    //累加 OK数量
 537   3              }
 538   2              else if(PKG == Package_2)
 539   2              {
 540   3                at24c02_rddat(COUNT2_OK_ADD,&countmp,4);
 541   3                countmp ++;
 542   3            at24c02_wrdat(COUNT2_OK_ADD,&countmp,4);    //累加 OK数量
 543   3              }
 544   2              else if(PKG == Package_3)
 545   2              {
 546   3                at24c02_rddat(COUNT3_OK_ADD,&countmp,4);
 547   3                countmp ++;
 548   3            at24c02_wrdat(COUNT3_OK_ADD,&countmp,4);    //累加 OK数量
 549   3              }
 550   2              at24c02_rddat(COUNTALL_OK_ADD,&countmp,4);
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 10  

 551   2              countmp ++;
 552   2              at24c02_wrdat(COUNTALL_OK_ADD,&countmp,4);    //累加 OK数量  
 553   2      #endif
 554   2      /*****************************************************************************************************/
 555   2        }
 556   1         
 557   1      }
 558          /************************************************************************************************
 559          烧码
 560          ************************************************************************************************/
 561          void CobCuting(u32 Add)
 562          {
 563   1              storge595(&Add,4);
 564   1              ENVMOS();                     // 开mos电源
 565   1              ENABLE595();              // 开595控制mos开关
 566   1              Cutflag = 1;
 567   1      }
 568          
 569          void StartCut(u8 package)
 570          {
 571   1        PnMask(package);            //转码
 572   1        CobCuting(PN.PadByte);      //开始割码
 573   1        while(Cutflag)                          //等待割码完成 才可以去读引脚阻值
 574   1        NOP1();
 575   1        GetPadRes();                //读引脚阻值
 576   1        OLED_Clear();
 577   1        compareAdd();               //比较地址
 578   1      }
 579          void ShowInfo(void)
 580          {
 581   1          u32 tmp;
 582   1      
 583   1              memcpy(OLED_GRAM_TMP,OLED_GRAM,512);
 584   1              init_windows(0,0,120,32,"Info",0,0);
 585   1              OLED_Draw_WindowsDraw(&windemo);
 586   1              tmp = Get_Pkg_CNT(PKG,0);
 587   1      
 588   1              OLED_ShowString(2,11,"OK:",7,1);   //Disp ok!
 589   1          OLED_ShowChar(22,11,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 590   1          OLED_ShowChar(28,11,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 591   1      
 592   1              OLED_ShowChar(34,11,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 593   1              OLED_ShowChar(40,11,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 594   1      
 595   1              OLED_ShowChar(46,11,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 596   1              OLED_ShowChar(52,11,Hex2Dat(((tmp)&0x0f)),7,1);
 597   1      
 598   1              tmp = Get_Pkg_CNT(PKG,1);
 599   1              OLED_ShowString(62,11,"NG:",7,1);   //Disp ok!
 600   1          OLED_ShowChar(82,11,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 601   1          OLED_ShowChar(88,11,Hex2Dat(((tmp>>16)&0x0f)),7,1);
 602   1      
 603   1              OLED_ShowChar(94,11,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 604   1              OLED_ShowChar(100,11,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 605   1      
 606   1              OLED_ShowChar(106,11,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 607   1              OLED_ShowChar(112,11,Hex2Dat(((tmp)&0x0f)),7,1);
 608   1      
 609   1              tmp = Get_Pkg_Add(PKG);
 610   1              OLED_ShowString(2,20,"ADD:",7,1);   //Disp ok!
 611   1          OLED_ShowChar(22,20,Hex2Dat(((tmp>>16)>>4)&0x0f),7,1);
 612   1          OLED_ShowChar(28,20,Hex2Dat(((tmp>>16)&0x0f)),7,1);
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 11  

 613   1      
 614   1              OLED_ShowChar(34,20,Hex2Dat(((tmp>>8)>>4)&0x0f),7,1);
 615   1              OLED_ShowChar(40,20,Hex2Dat(((tmp>>8)&0x0f)),7,1);
 616   1      
 617   1              OLED_ShowChar(46,20,Hex2Dat(((tmp)>>4)&0x0f),7,1);
 618   1              OLED_ShowChar(52,20,Hex2Dat(((tmp)&0x0f)),7,1);
 619   1      
 620   1              POP = 2;
 621   1              OLED_Refresh_Gram();      
 622   1      }
 623          void CutRun(u8 package)
 624          {
 625   1        u8 Done;
 626   1        Done = 0;
 627   1        //获取封装信息
 628   1      #ifdef EEPROM_EN
 629   1          PN_TMP.PadByte = Get_Pkg_Add(package); //获取到对应封装割码地址
 630   1      #endif
 631   1              OLED_ShowString(30,0,"SADD-No.:",12,1); 
 632   1          OLED_ShowChar(0,15,Hex2Dat(((PN_TMP.PadByte>>16)>>4)&0x0f),12,1);
 633   1          OLED_ShowChar(8,15,Hex2Dat(((PN_TMP.PadByte>>16)&0x0f)),12,1);
 634   1      
 635   1              OLED_ShowChar(16,15,Hex2Dat(((PN_TMP.PadByte>>8)>>4)&0x0f),12,1);
 636   1              OLED_ShowChar(24,15,Hex2Dat(((PN_TMP.PadByte>>8)&0x0f)),12,1);
 637   1      
 638   1              OLED_ShowChar(32,15,Hex2Dat(((PN_TMP.PadByte)>>4)&0x0f),12,1);
 639   1              OLED_ShowChar(40,15,Hex2Dat(((PN_TMP.PadByte)&0x0f)),12,1);
 640   1          OLED_Refresh_Gram();
 641   1              memcpy(OLED_GRAM_TMP,OLED_GRAM,512);
 642   1        while(!Done)
 643   1        {
 644   2                if((Key_back == PR_MOD)&&(Key_change))
 645   2                {
 646   3                 Key_change=0; 
 647   3                 BeepFlag =1; 
 648   3             StartCut(package);
 649   3                }
 650   2                if((Key_back == PR_OK)&&(Key_change))
 651   2                {
 652   3                 Key_change=0; 
 653   3                 BeepFlag =1;
 654   3                 ShowInfo();
 655   3                }         
 656   2        }
 657   1      }
 658          /*
 659          void TestPn(void)
 660          {
 661            static u8 Done = 0;
 662            PN_TMP.PadByte = 0;
 663            PN.PadByte = 0;
 664            send_string("\nstart mask: package type 1 , PACK_ADD = 0 , IC_ADD = 0\n\n");
 665          //  PN_TMP.Px.Pad0 = 1;
 666          //  PN.Px.Pad1 = 1;
 667          //  printf_u8(PN_TMP.PadByte);
 668          //  printf_u8(PN.PadByte);
 669          //      send_string("   ===>masking...\n");
 670            while(!Done)
 671            {
 672                  PnMask(0);
 673          //      send_string("start mask: ");
 674          //      send_string("PACK_ADD=:");
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 12  

 675          //      printf_u8(PN_TMP.PadByte>>24);
 676          //      printf_u8(PN_TMP.PadByte>>16);
 677          //      printf_u8(PN_TMP.PadByte>>8);
 678          //      printf_u8(PN_TMP.PadByte);
 679          //      send_string("   IC_ADD=:");
 680          //      printf_u8(PN.PadByte>>24);
 681          //      printf_u8(PN.PadByte>>16);
 682          //      printf_u8(PN.PadByte>>8);
 683          //      printf_u8(PN.PadByte);
 684          //      send_string("   ===>masking...\n");
 685          //      send_string("PACK_ADD.BIT0 = \n");
 686          //      printf_u8(PN_TMP.Px.Pad0);
 687                  send_string("\n");
 688                  send_string("PN_TMP BIT 15:0\n");
 689                  printf_u8(PN_TMP.Px.P_XHX.Pad7);
 690                  printf_u8(PN_TMP.Px.P_XHX.Pad6);
 691                  printf_u8(PN_TMP.Px.P_XHX.Pad5);
 692                  printf_u8(PN_TMP.Px.P_XHX.Pad4);
 693                  printf_u8(PN_TMP.Px.P_XHX.Pad3);
 694                  printf_u8(PN_TMP.Px.P_XHX.Pad2);
 695                  printf_u8(PN_TMP.Px.P_XHX.Pad1);
 696                  printf_u8(PN_TMP.Px.P_XHX.Pad0);        
 697                  
 698                  printf_u8(PN_TMP.Px.P_XXH.Pad7);
 699                  printf_u8(PN_TMP.Px.P_XXH.Pad6);
 700                  printf_u8(PN_TMP.Px.P_XXH.Pad5);
 701                  printf_u8(PN_TMP.Px.P_XXH.Pad4);
 702                  printf_u8(PN_TMP.Px.P_XXH.Pad3);
 703                  printf_u8(PN_TMP.Px.P_XXH.Pad2);
 704                  printf_u8(PN_TMP.Px.P_XXH.Pad1);
 705                  printf_u8(PN_TMP.Px.P_XXH.Pad0);
 706          //      send_string("\n");
 707                  send_string("PN_TMP BIT 15:0\n");
 708                  printf_u8(PN.Px.P_XHX.Pad7);
 709                  printf_u8(PN.Px.P_XHX.Pad6);
 710                  printf_u8(PN.Px.P_XHX.Pad5);
 711                  printf_u8(PN.Px.P_XHX.Pad4);
 712                  printf_u8(PN.Px.P_XHX.Pad3);
 713                  printf_u8(PN.Px.P_XHX.Pad2);
 714                  printf_u8(PN.Px.P_XHX.Pad1);
 715                  printf_u8(PN.Px.P_XHX.Pad0);    
 716                  
 717                  printf_u8(PN.Px.P_XXH.Pad7);
 718                  printf_u8(PN.Px.P_XXH.Pad6);
 719                  printf_u8(PN.Px.P_XXH.Pad5);
 720                  printf_u8(PN.Px.P_XXH.Pad4);
 721                  printf_u8(PN.Px.P_XXH.Pad3);
 722                  printf_u8(PN.Px.P_XXH.Pad2);
 723                  printf_u8(PN.Px.P_XXH.Pad1);
 724                  printf_u8(PN.Px.P_XXH.Pad0);
 725                  send_string("\n");              
 726                  if(PN_TMP.PadByte ++ >=0xfff)
 727                  Done = 1;
 728            }
 729                  send_string("mask over!\n");
 730          }
 731          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4153    ----
   CONSTANT SIZE    =     49    ----
C51 COMPILER V9.00   CD4052                                                                04/22/2015 18:31:49 PAGE 13  

   XDATA SIZE       =     52      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
